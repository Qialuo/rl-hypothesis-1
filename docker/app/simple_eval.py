
# Before running more-advanced experiments, I want to test for feasibility. 
# In an advanced evaluation, sampling should reflect the automaton's 
# experience, with the GAN being trained on only the observed real data. 
# In this simple evaluation, the GAN will not be trained--I need to 
# justify the engineering work first. The GAN is trained on a single, 
# large dataset. The evaluation will work as follows.
# 1. Sample data, pooling simulants with real. 
# 2. Fit the q-net 
# 3. Generate the metric: %-wins of game trials 

## libraries 
from gcp_api_wrapper import download_blob, upload_blob, shutdown
from cgan import CGAN
from transfer_sampler import _map_array_to_transfers, _map_int_to_reward_dead  
import os 
import pickle 
import numpy as np 

## constants 
CGAN_DATA_PATH='/app/cgan-data.pkl'
CGAN_DATA_BLOB_NAME='cgan-data.pkl'
CGAN_MODEL_PATH='/app/cgan-model.h5'
CGAN_MODEL_BLOB_NAME='cgan-model.h5'
FULL_RL_MODEL_PATH='/app/breakout_dqn.h5'
FULL_RL_MODEL_BLOB_NAME='rl-full.h5'

# ensure files are downloaded 
if not os.path.isfile(CGAN_DATA_PATH): 
    download_blob(CGAN_DATA_BLOB_NAME, CGAN_DATA_PATH) 
if not os.path.isfile(CGAN_MODEL_PATH): 
    download_blob(CGAN_MODEL_BLOB_NAME, CGAN_MODEL_PATH) 
if not os.path.isfile(FULL_RL_MODEL_PATH):
    download_blob(FULL_RL_MODEL_BLOB_NAME, FULL_RL_MODEL_PATH) 

# load files 
with open(CGAN_DATA_PATH, 'rb') as f: 
    CGAN_DATA = pickle.load(f)
CGAN_MODEL = CGAN(load_model_name=CGAN_MODEL_PATH)
with open(FULL_RL_MODEL_PATH, 'rb') as f:
    #RULL_RL_MODEL = pickle.load(f)  
    pass

def simple_sample(sample_size, probability_simulated): 
    '''
    Generates a mixed dataset of simulated and real embedded samples. 
    Samples are "embedded" because we've used transfer learning. 
    Sampling is "simple" because the GAN is not fit with each simple. 
    '''
    n_fake = np.random.binomial(sample_size, probability_simulated) 
    n_real = sample_size - n_fake 
    ## sample real data 
    ## sample fake data 
    ## merge and return 
    pass

def fit(data):
    '''
    Fits a transfer-learned model on embedded data. Once fit, the 
    abstract model is combined with its lower parts (ie. convolutions) 
    and returned. Metrics are also returned to support later diagnostics. 
    '''
    ## Fit q-net on data 
    ## Combine with lower transfer-learned layers
    ## Return model and metrics 
    pass

def metric_trials(model, sample_size): 
    '''
    Metric: Percent-win of games per model. 
    '''
    pass

def __sample_real_data(n):
    pass

def __sample_fake_data(n, gan):
    '''
    Fake data is generated by a cGAN. Conditioned states are sampled 
    from a choice distribution. 
    '''
    # semi-stratified sampling over `(rewarded and dead)`. 
    # `action` assumed uniformly distributed. 
    labels = np.random.choice([0,1,2,3,4,5,6,7,8], p=[.01/3, .03/3, .96/3]*3, size=n) 
    noise = np.random.normal(0, 1, (n, 100)) 
    fake_data_raw = CGAN_MODEL.generator.predict([noise, labels]) 
    # data needs to be transformed into `(state_t, action_t, reward_t, state_t+1, dead_t)` 
    pass

if __name__ == '__main__': 
    # TODO  















